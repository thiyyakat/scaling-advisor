package api

import (
	"context"
	commontypes "github.com/gardener/scaling-advisor/api/common/types"
	corev1alpha1 "github.com/gardener/scaling-advisor/api/core/v1alpha1"
	mkapi "github.com/gardener/scaling-advisor/minkapi/api"
	corev1 "k8s.io/api/core/v1"
	nodev1 "k8s.io/api/node/v1"
	schedulingv1 "k8s.io/api/scheduling/v1"
	"k8s.io/apimachinery/pkg/types"
	"k8s.io/client-go/dynamic"
	"k8s.io/client-go/dynamic/dynamicinformer"
	"k8s.io/client-go/informers"
	"k8s.io/client-go/kubernetes"
	"k8s.io/client-go/tools/events"
	"time"
)

const (
	// ServiceName is the name of the scaling advisor service.
	ServiceName = "scaling-advisor"
)

// ScalingAdviceResponseType defines the type of response that can be sent by the scaling advisor service.
type ScalingAdviceResponseType string

const (
	// ScalingAdviceResponseTypeCreate is used when the scaling advice is created.
	ScalingAdviceResponseTypeCreate ScalingAdviceResponseType = "Create"
	// ScalingAdviceResponseTypeUpdate is used when the scaling advice is updated.
	ScalingAdviceResponseTypeUpdate ScalingAdviceResponseType = "Update"
	// ScalingAdviceResponseTypeStatusUpdate is used when the scaling advice status is updated.
	ScalingAdviceResponseTypeStatusUpdate ScalingAdviceResponseType = "UpdateStatus"
	// ScalingAdviceResponseTypeComplete is used when the scaling advice generation is completed.
	ScalingAdviceResponseTypeComplete ScalingAdviceResponseType = "Complete"
)

type ScalingAdviceGenerationStrategy string

const (
	IncrementalScalingAdviceGenerationStrategy ScalingAdviceGenerationStrategy = "Incremental"
	AllInOneScalingAdviceGenerationStrategy    ScalingAdviceGenerationStrategy = "AllInOne"
)

// ScalingAdviceRequest encapsulates the request parameters for generating scaling advice.
type ScalingAdviceRequest struct {
	// ID is the unique identifier for the request.
	ID string
	// CorrelationID is the correlation identifier for the request, used to correlate a request and one or more responses.
	CorrelationID string
	// GenerationStrategy
	GenerationStrategy ScalingAdviceGenerationStrategy
	// Constraint is the cluster scaling constraint using which the scaling advice is generated.
	Constraint corev1alpha1.ClusterScalingConstraint
	// Snapshot is the snapshot of the resources in the cluster at the time of the request.
	Snapshot ClusterSnapshot
	// Feedback captures feedback from the consumer of the scaling advice, which can be used to improve future scaling advice generation.
	Feedback *corev1alpha1.ClusterScalingFeedback
}

// ScalingAdviceResponse encapsulates the response from the scaling advisor service.
type ScalingAdviceResponse struct {
	// RequestID is the Request unique identifier for which this response is generated.
	RequestID string
	// CorrelationID is the correlation identifier for the request, used to correlate this response with the request.
	CorrelationID string
	// ResponseType indicates the type of response being sent.
	ResponseType ScalingAdviceResponseType
	// Message is a human-readable message providing additional context about the response.
	Message string
	// ScalingAdvice contains the scaling advice generated by the scaling advisor service.
	ScalingAdvice *corev1alpha1.ClusterScalingAdvice
}

// ScalingAdvisorServiceConfig holds the configuration for the scaling advisor service.
type ScalingAdvisorServiceConfig struct {
	// MinKAPIConfig holds the configuration for the MinKAPI server used by the scaling advisor service.
	MinKAPIConfig mkapi.MinKAPIConfig
	// SchedulerConfigPath is the path to the kube-scheduler configuration file.
	SchedulerConfigPath string
	// MaxConcurrentSimulations is the maximum number of concurrent simulations that can be run by the scaling advisor service.
	MaxConcurrentSimulations int
}

// ScalingAdviceResponseFn is a callback function which is invoked by the scaling advisor service when generating scaling advice.
// The callback maybe invoked zero or more times during the generation of scaling advice with callbackType representing the type of change in the scaling advice.
type ScalingAdviceResponseFn func(response ScalingAdviceResponse) error

// ScalingAdvisorService defines the interface for the scaling advisor service.
type ScalingAdvisorService interface {
	// GenerateScalingAdvice generates scaling advice based on the provided request and invokes the responseFn callback with the generated advice.
	GenerateScalingAdvice(ctx context.Context, request ScalingAdviceRequest, responseFn ScalingAdviceResponseFn) error
}

// SchedulerLaunchParams holds the parameters required to launch a kube-scheduler instance.
type SchedulerLaunchParams struct {
	// Client is the Kubernetes client used to interact with the cluster.
	Client kubernetes.Interface
	// DynClient is the dynamic Kubernetes client used to interact with the cluster.
	DynClient dynamic.Interface
	// InformerFactory is the shared informer factory used to create informers for the cluster resources.
	InformerFactory informers.SharedInformerFactory
	// DynInformerFactory is the dynamic shared informer factory used to create informers for the cluster resources.
	DynInformerFactory dynamicinformer.DynamicSharedInformerFactory
	// EventSink is the event sink used to send events from the kube-scheduler.
	EventSink events.EventSink
}

// SchedulerLauncher defines the interface for launching a kube-scheduler instance.
// There will be limited number of kube-scheduler instances that can be launched at a time.
type SchedulerLauncher interface {
	// Launch launches and runs an embedded scheduler instance asynchronously.
	// If the limit of running schedulers is reached, it will block.
	// An error is returned if the scheduler fails to start.
	Launch(ctx context.Context, params *SchedulerLaunchParams) (SchedulerHandle, error)
}

// SchedulerHandle defines the interface for managing a kube-scheduler instance.
type SchedulerHandle interface {
	// Stop stops the scheduler instance.
	Stop()
	// GetParams returns the parameters used to launch the scheduler instance.
	GetParams() SchedulerLaunchParams
}

// ClusterSnapshot represents a snapshot of the cluster at a specific time and encapsulates the scheduling relevant information required by the kube-scheduler.
type ClusterSnapshot struct {
	// Pods are the pods that are present in the cluster.
	Pods []PodInfo
	// Nodes are the nodes that are present in the cluster.
	Nodes []NodeInfo
	// PriorityClasses are the priority classes that are present in the cluster.
	PriorityClasses []schedulingv1.PriorityClass
	// RuntimeClasses are the runtime classes that are present in the cluster.
	RuntimeClasses []nodev1.RuntimeClass
}

func (c *ClusterSnapshot) GetUnscheduledPods() []PodInfo {
	var unscheduledPods []PodInfo
	for _, pod := range c.Pods {
		if pod.NodeName == "" {
			unscheduledPods = append(unscheduledPods, pod)
		}
	}
	return unscheduledPods
}

// PodInfo contains the minimum set of information about corev1.Pod that will be required by the kube-scheduler.
// NOTES:
//  1. PodSchedulingGates is not part of PodInfo. It is expected that pods having scheduling gates will be filtered out before setting up simulation runs.
//  2. Consider including PodSpec.Resources in future when it graduates to beta/GA.
type PodInfo struct {
	ResourceMeta
	// AggregatedRequests is an aggregated resource requests for all containers of the Pod.
	AggregatedRequests map[corev1.ResourceName]int64
	// Volumes are the volumes that are attached to the Pod.
	Volumes []corev1.Volume `json:"volumes"`
	// NodeSelector is the node selector for the Pod.
	NodeSelector map[string]string
	// NodeName is the name of the node where the Pod is scheduled.
	NodeName string
	// Affinity is the affinity rules for the Pod.
	Affinity *corev1.Affinity
	// SchedulerName is the name of the scheduler that should be used to schedule the Pod.
	SchedulerName string
	// Tolerations are the tolerations for the Pod.
	Tolerations []corev1.Toleration
	// PriorityClassName is the name of the priority class that should be used to schedule the Pod.
	PriorityClassName         string
	Priority                  *int32
	PreemptionPolicy          *corev1.PreemptionPolicy
	RuntimeClassName          *string
	Overhead                  map[corev1.ResourceName]int64
	TopologySpreadConstraints []corev1.TopologySpreadConstraint
	ResourceClaims            []corev1.PodResourceClaim
}

func (p *PodInfo) GetResourceInfo() PodResourceInfo {
	return PodResourceInfo{
		UID:                p.UID,
		NamespacedName:     p.NamespacedName,
		AggregatedRequests: p.AggregatedRequests,
	}
}

// NodeInfo contains the minimum set of information about corev1.Node that will be required by the kube-scheduler.
type NodeInfo struct {
	ResourceMeta
	// InstanceType is the instance type for the Node.
	InstanceType string
	// Unschedulable indicates whether the node is unschedulable.
	Unschedulable bool
	// Taints are the node's taints.
	Taints []corev1.Taint
	// Capacity is the total resource capacity of the node.
	Capacity map[corev1.ResourceName]int64
	// Allocatable is the allocatable resource capacity of the node.
	Allocatable map[corev1.ResourceName]int64
	// CSIDriverVolumeMaximums is a map of CSI driver names to the maximum number of unique volumes managed by the
	// CSI driver that can be used on a node.
	CSIDriverVolumeMaximums map[string]int32
}

func (n *NodeInfo) GetResourceInfo() NodeResourceInfo {
	return NodeResourceInfo{
		Name:         n.Name,
		InstanceType: n.InstanceType,
		Capacity:     n.Capacity,
		Allocatable:  n.Allocatable,
	}
}

type ResourceMeta struct {
	// UID is the unique identifier for the resource.
	UID types.UID
	types.NamespacedName
	// Labels are the labels associated with the resource.
	Labels map[string]string
	// DeletionTimestamp is the timestamp when the resource deletion was triggered.
	DeletionTimestamp time.Time
}

// NodeScore to be documented later.
type NodeScore struct {
	// SimulationName is the unique name of the simulation that produces this NodeScore.
	SimulationName string
	// Placement represents the placement information for the Node.
	Placement       NodePlacementInfo
	UnscheduledPods []PodResourceInfo
	// Value is the score value for this Node.
	Value int
}

type InstancePricing interface {
	GetPrice(region, instanceType string) (float64, error)
}
type GetInstancePricing func(provider commontypes.CloudProvider, pricingDataPath string) (InstancePricing, error)

type NodeScorer interface {
	Compute(args NodeScoreArgs) (NodeScore, error)
}

type GetNodeScorer func(scoringStrategy commontypes.NodeScoringStrategy, instancePricing InstancePricing) (NodeScorer, error)

type PodResourceInfo struct {
	UID types.UID
	types.NamespacedName
	// AggregatedRequests is an aggregated resource requests for all containers of the Pod.
	AggregatedRequests map[corev1.ResourceName]int64
}

// NodeResourceInfo represents the subset of NodeInfo such that NodeScorer can compute an effective NodeScore.
// TODO think of a better name.
type NodeResourceInfo struct {
	Name         string
	InstanceType string
	// Capacity is the total resource capacity of the node.
	Capacity map[corev1.ResourceName]int64
	// Allocatable is the allocatable resource capacity of the node.
	Allocatable map[corev1.ResourceName]int64
}

type NodePlacementInfo struct {
	// NodePoolName is the name of the node pool.
	NodePoolName string
	// NodeTemplateName is the name of the node template.
	NodeTemplateName string
	// InstanceType is the instance type of the Node.
	InstanceType string
	// AvailabilityZone is the availability zone of the node pool.
	AvailabilityZone string
}

type NodeScoreArgs struct {
	// SimulationName is the unique simulation name.
	SimulationName string
	// Placement represents the placement information for the Node.
	Placement NodePlacementInfo
	// ScaledAssignment represents the assignment of the scaled Node for the current run.
	ScaledAssignment *NodePodAssignment
	// Assignments represents the assignment of unscheduled Pods to either an existing Node which is part of the ClusterSnapshot
	// or it is a winning simulated Node from a previous run.
	Assignments     []*NodePodAssignment
	UnscheduledPods []PodResourceInfo
}

type NodePodAssignment struct {
	Node          *NodeResourceInfo
	ScheduledPods []*PodResourceInfo
}

// NodeScoreSelector selects the winning NodeScore amongst the NodeScores of a given simulation pass and returns its index.
// If there is no winning node score then it returns -1.
type NodeScoreSelector func(nodeScores ...NodeScore) int
