package api

import (
	"context"
	"fmt"
	commontypes "github.com/gardener/scaling-advisor/api/common/types"
	corev1alpha1 "github.com/gardener/scaling-advisor/api/core/v1alpha1"
	mkapi "github.com/gardener/scaling-advisor/minkapi/api"
	corev1 "k8s.io/api/core/v1"
	nodev1 "k8s.io/api/node/v1"
	schedulingv1 "k8s.io/api/scheduling/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/types"
	"k8s.io/client-go/dynamic"
	"k8s.io/client-go/dynamic/dynamicinformer"
	"k8s.io/client-go/informers"
	"k8s.io/client-go/kubernetes"
	"k8s.io/client-go/tools/events"
	"time"
)

const (
	// ServiceName is the name of the scaling advisor service.
	ServiceName = "scaling-advisor"
)

// ScalingAdviceResponseType defines the type of response that can be sent by the scaling advisor service.
type ScalingAdviceResponseType string

const (
	// ScalingAdviceResponseTypeCreate is used when the scaling advice is created.
	ScalingAdviceResponseTypeCreate ScalingAdviceResponseType = "Create"
	// ScalingAdviceResponseTypeUpdate is used when the scaling advice is updated.
	ScalingAdviceResponseTypeUpdate ScalingAdviceResponseType = "Update"
	// ScalingAdviceResponseTypeStatusUpdate is used when the scaling advice status is updated.
	ScalingAdviceResponseTypeStatusUpdate ScalingAdviceResponseType = "UpdateStatus"
	// ScalingAdviceResponseTypeComplete is used when the scaling advice generation is completed.
	ScalingAdviceResponseTypeComplete ScalingAdviceResponseType = "Complete"
)

type ScalingAdviceGenerationStrategy string

const (
	IncrementalScalingAdviceGenerationStrategy ScalingAdviceGenerationStrategy = "Incremental"
	AllInOneScalingAdviceGenerationStrategy    ScalingAdviceGenerationStrategy = "AllInOne"
)

// ActivityStatus represents the operational status of an activity
type ActivityStatus string

const (
	ActivityStatusPending ActivityStatus = "Pending"
	ActivityStatusRunning ActivityStatus = "Running"
	ActivityStatusSuccess ActivityStatus = metav1.StatusSuccess
	ActivityStatusFailure ActivityStatus = metav1.StatusFailure
)

// ScalingAdviceRequest encapsulates the request parameters for generating scaling advice.
type ScalingAdviceRequest struct {
	// ID is the unique identifier for the request.
	ID string
	// CorrelationID is the correlation identifier for the request, used to correlate a request and one or more responses.
	CorrelationID string
	// GenerationStrategy
	GenerationStrategy ScalingAdviceGenerationStrategy
	// Constraint is the cluster scaling constraint using which the scaling advice is generated.
	Constraint corev1alpha1.ClusterScalingConstraint
	// Snapshot is the snapshot of the resources in the cluster at the time of the request.
	Snapshot ClusterSnapshot
	// Feedback captures feedback from the consumer of the scaling advice, which can be used to improve future scaling advice generation.
	Feedback *corev1alpha1.ClusterScalingFeedback
}

// ScalingAdviceResponse encapsulates the response from the scaling advisor service.
type ScalingAdviceResponse struct {
	// RequestID is the Request unique identifier for which this response is generated.
	RequestID string
	// CorrelationID is the correlation identifier for the request, used to correlate this response with the request.
	CorrelationID string
	// ResponseType indicates the type of response being sent.
	ResponseType ScalingAdviceResponseType
	// Message is a human-readable message providing additional context about the response.
	Message string
	// ScalingAdvice contains the scaling advice generated by the scaling advisor service.
	ScalingAdvice *corev1alpha1.ClusterScalingAdvice
}

// ScalingAdvisorServiceConfig holds the configuration for the scaling advisor service.
type ScalingAdvisorServiceConfig struct {
	// MinKAPIConfig holds the configuration for the MinKAPI server used by the scaling advisor service.
	MinKAPIConfig mkapi.MinKAPIConfig
	// SchedulerConfigPath is the path to the kube-scheduler configuration file.
	SchedulerConfigPath string
	// MaxConcurrentSimulations is the maximum number of concurrent simulations that can be run by the scaling advisor service.
	MaxConcurrentSimulations int
}

// ScalingAdviceResponseFn is a callback function which is invoked by the scaling advisor service when generating scaling advice.
// The callback maybe invoked zero or more times during the generation of scaling advice with callbackType representing the type of change in the scaling advice.
type ScalingAdviceResponseFn func(response ScalingAdviceResponse) error

// ScalingAdvisorService defines the facade for the scaling advisor service.
type ScalingAdvisorService interface {
	commontypes.Service
	// GenerateScalingAdvice generates scaling advice based on the provided request and invokes the responseFn callback with the generated advice.
	GenerateScalingAdvice(ctx context.Context, request ScalingAdviceRequest, responseFn ScalingAdviceResponseFn) error
}

// SchedulerLaunchParams holds the parameters required to launch a kube-scheduler instance.
type SchedulerLaunchParams struct {
	// Client is the Kubernetes client used to interact with the cluster.
	Client kubernetes.Interface
	// DynClient is the dynamic Kubernetes client used to interact with the cluster.
	DynClient dynamic.Interface
	// InformerFactory is the shared informer factory used to create informers for the cluster resources.
	InformerFactory informers.SharedInformerFactory
	// DynInformerFactory is the dynamic shared informer factory used to create informers for the cluster resources.
	DynInformerFactory dynamicinformer.DynamicSharedInformerFactory
	// EventSink is the event sink used to send events from the kube-scheduler.
	EventSink events.EventSink
}

// SchedulerLauncher defines the interface for launching a kube-scheduler instance.
// There will be a limited number of kube-scheduler instances that can be launched at a time.
type SchedulerLauncher interface {
	// Launch launches and runs an embedded scheduler instance asynchronously.
	// If the limit of running schedulers is reached, it will block.
	// An error is returned if the scheduler fails to start.
	Launch(ctx context.Context, params *SchedulerLaunchParams) (SchedulerHandle, error)
}

// SchedulerHandle defines the interface for managing a kube-scheduler instance.
type SchedulerHandle interface {
	// Stop stops the scheduler instance.
	Stop()
	// GetParams returns the parameters used to launch the scheduler instance.
	GetParams() SchedulerLaunchParams
}

// ClusterSnapshot represents a snapshot of the cluster at a specific time and encapsulates the scheduling relevant information required by the kube-scheduler.
type ClusterSnapshot struct {
	// Pods are the pods that are present in the cluster.
	Pods []PodInfo
	// Nodes are the nodes that are present in the cluster.
	Nodes []NodeInfo
	// PriorityClasses are the priority classes that are present in the cluster.
	PriorityClasses []schedulingv1.PriorityClass
	// RuntimeClasses are the runtime classes that are present in the cluster.
	RuntimeClasses []nodev1.RuntimeClass
}

func (c *ClusterSnapshot) GetUnscheduledPods() []PodInfo {
	var unscheduledPods []PodInfo
	for _, pod := range c.Pods {
		if pod.NodeName == "" {
			unscheduledPods = append(unscheduledPods, pod)
		}
	}
	return unscheduledPods
}

// PodInfo contains the minimum set of information about corev1.Pod that will be required by the kube-scheduler.
// NOTES:
//  1. PodSchedulingGates is not part of PodInfo. It is expected that pods having scheduling gates will be filtered out before setting up simulation runs.
//  2. Consider including PodSpec.Resources in future when it graduates to beta/GA.
type PodInfo struct {
	ResourceMeta
	// AggregatedRequests is an aggregated resource requests for all containers of the Pod.
	AggregatedRequests map[corev1.ResourceName]int64
	// Volumes are the volumes that are attached to the Pod.
	Volumes []corev1.Volume `json:"volumes"`
	// NodeSelector is the node selector for the Pod.
	NodeSelector map[string]string
	// NodeName is the name of the node where the Pod is scheduled.
	NodeName string
	// Affinity is the affinity rules for the Pod.
	Affinity *corev1.Affinity
	// SchedulerName is the name of the scheduler that should be used to schedule the Pod.
	SchedulerName string
	// Tolerations are the tolerations for the Pod.
	Tolerations []corev1.Toleration
	// PriorityClassName is the name of the priority class that should be used to schedule the Pod.
	PriorityClassName         string
	Priority                  *int32
	PreemptionPolicy          *corev1.PreemptionPolicy
	RuntimeClassName          *string
	Overhead                  map[corev1.ResourceName]int64
	TopologySpreadConstraints []corev1.TopologySpreadConstraint
	ResourceClaims            []corev1.PodResourceClaim
}

func (p *PodInfo) GetResourceInfo() PodResourceInfo {
	return PodResourceInfo{
		UID:                p.UID,
		NamespacedName:     p.NamespacedName,
		AggregatedRequests: p.AggregatedRequests,
	}
}

// NodeInfo contains the minimum set of information about corev1.Node that will be required by the kube-scheduler.
type NodeInfo struct {
	ResourceMeta
	// InstanceType is the instance type for the Node.
	InstanceType string
	// Unschedulable indicates whether the node is unschedulable.
	Unschedulable bool
	// Taints are the node's taints.
	Taints []corev1.Taint
	// Capacity is the total resource capacity of the node.
	Capacity map[corev1.ResourceName]int64
	// Allocatable is the allocatable resource capacity of the node.
	Allocatable map[corev1.ResourceName]int64
	// CSIDriverVolumeMaximums is a map of CSI driver names to the maximum number of unique volumes managed by the
	// CSI driver that can be used on a node.
	CSIDriverVolumeMaximums map[string]int32
}

func (n *NodeInfo) GetResourceInfo() NodeResourceInfo {
	return NodeResourceInfo{
		Name:         n.Name,
		InstanceType: n.InstanceType,
		Capacity:     n.Capacity,
		Allocatable:  n.Allocatable,
	}
}

type ResourceMeta struct {
	// UID is the unique identifier for the resource.
	UID types.UID
	types.NamespacedName
	// Labels are the labels associated with the resource.
	Labels map[string]string
	// DeletionTimestamp is the timestamp when the resource deletion was triggered.
	DeletionTimestamp time.Time
}

type InstancePricing interface {
	GetPrice(region, instanceType string) (float64, error)
}
type GetInstancePricing func(provider commontypes.CloudProvider, pricingDataPath string) (InstancePricing, error)

type NodeScorer interface {
	Compute(args NodeScoreArgs) (NodeScore, error)
}
type NodeScoreArgs struct {
	// Name that must given to the NodeScore produced by the NodeScorer
	Name string
	// Placement represents the placement information for the Node.
	Placement NodePlacementInfo
	// ScaledAssignment represents the assignment of the scaled Node for the current run.
	ScaledAssignment *NodePodAssignment
	// Assignments represent the assignment of unscheduled Pods to either an existing Node which is part of the ClusterSnapshot
	// or it is a winning simulated Node from a previous run.
	Assignments []NodePodAssignment
	// UnscheduledPods is the slice of unscheduled pods that remain unscheduled after simulation is completed.
	UnscheduledPods []PodResourceInfo
}

// NodeScore to be documented later.
type NodeScore struct {
	// Name is the name for this node score
	Name string
	// Placement represents the placement information for the Node.
	Placement       NodePlacementInfo
	UnscheduledPods []PodResourceInfo
	// Value is the score value for this Node.
	Value              int
	ScaledNodeResource *NodeResourceInfo
}

type GetNodeScorer func(scoringStrategy commontypes.NodeScoringStrategy, instancePricing InstancePricing, weights map[corev1.ResourceName]float64) (NodeScorer, error)
type GetNodeScoreSelector func(scoringStrategy commontypes.NodeScoringStrategy) (NodeScoreSelector, error)

type PodResourceInfo struct {
	UID types.UID
	types.NamespacedName
	// AggregatedRequests is an aggregated resource requests for all containers of the Pod.
	AggregatedRequests map[corev1.ResourceName]int64
}

// NodeResourceInfo represents the subset of NodeInfo such that NodeScorer can compute an effective NodeScore.
// TODO think of a better name.
type NodeResourceInfo struct {
	Name         string
	InstanceType string
	// Capacity is the total resource capacity of the node.
	Capacity map[corev1.ResourceName]int64
	// Allocatable is the allocatable resource capacity of the node.
	Allocatable map[corev1.ResourceName]int64
}

type NodePlacementInfo struct {
	// NodePoolName is the name of the node pool.
	NodePoolName string
	// NodeTemplateName is the name of the node template.
	NodeTemplateName string
	// InstanceType is the instance type of the Node.
	InstanceType string
	// AvailabilityZone is the availability zone of the node pool.
	AvailabilityZone string
}

type NodePodAssignment struct {
	Node          NodeResourceInfo
	ScheduledPods []PodResourceInfo
}

// NodeScoreSelector selects the winning NodeScore amongst the NodeScores of a given simulation pass and returns its index.
// If there is no winning node score amongst the group, then it returns -1.
type NodeScoreSelector func(groupNodeScores []NodeScore) (winningIndex int, err error)

// Simulation represents an activity that performs valid unscheduled pod to ready node assignments on a minkapi View.
// A simulation implementation may use a k8s scheduler - either embedded or external to do this, or it may form a SAT/MIP model
// from the pod/node data and run a tool that solves the model.
type Simulation interface {
	// Name returns the logical simulation name
	Name() string
	// ActivityStatus returns the current ActivityStatus of the simulation
	ActivityStatus() ActivityStatus
	// NodePool returns the target node pool against which the simulation should be run
	NodePool() *corev1alpha1.NodePool
	// NodeTemplate returns the target node template against which the simulation should be run
	NodeTemplate() *corev1alpha1.NodeTemplate
	// Run executes the simulation to completion and returns any encountered error. This is a blocking call and callers are
	// expected to manage concurrency and SimRunResult consumption.
	Run(ctx context.Context) error
	// Result returns the latest SimRunResult if the simulation is in ActivityStatusSuccess,
	// or nil if the simulation is in ActivityStatusPending or ActivityStatusRunning
	// or an error if the ActivityStatus is ActivityStatusFailure
	Result() (SimRunResult, error)
}

type SimRunResult struct {
	// Name of the Simulation that produced this result.
	Name string
	// ScaledNode is the simulated scaled node.
	ScaledNode *corev1.Node
	NodeScoreArgs
}

// SimulationArgs represents the argument necessary for creating a simulation instance.
type SimulationArgs struct {
	AvailabilityZone  string
	NodeTemplateName  string
	NodePool          *corev1alpha1.NodePool
	SchedulerLauncher SchedulerLauncher
	View              mkapi.View
}

// CreateSimulationFunc is a factory function for constructing a simulation instance
type CreateSimulationFunc func(name string, args *SimulationArgs) (Simulation, error)

// SimulationGroup is a group of simulations at the same priority level (ie a partition of simulations). We attempt to run simulations for the
// given group and get a preferred NodeScore for simulations belonging to a group before moving to the group at the
// next priority.
//
//	Example:1
//		np-a: 1 {nt-a: 1, nt-b: 2, nt-c: 1}
//		np-b: 2 {nt-q: 2, nt-r: 1, nt-s: 1}
//
//		p1: {PoolPriority: 1, NTPriority: 1, nt-a, nt-c}
//		p2: {PoolPriority: 1, NTPriority: 2, nt-b}
//		p3: {PoolPriority: 2, NTPriority: 1, nt-r, nt-s}
//		p4: {PoolPriority: 2, NTPriority: 2, nt-q}
//
//	Example:2
//		np-a: 1 {nt-a: 1, nt-b: 2, nt-c: 1}
//		np-b: 2 {nt-q: 2, nt-r: 1, nt-s: 1}
//		np-c: 1 {nt-x: 2, nt-y: 1}
//
//		p1: {PoolPriority: 1, NTPriority: 1, nt-a, nt-c, nt-y}
//		p2: {PoolPriority: 1, NTPriority: 2, nt-b, nt-x}
//		p3: {PoolPriority: 2, NTPriority: 1, nt-r, nt-s}
//		p4: {PoolPriority: 2, NTPriority: 2, nt-q}
type SimulationGroup interface {
	Name() string
	GetKey() SimGroupKey
	GetSimulations() []Simulation
	Run(ctx context.Context) (SimGroupRunResult, error)
}

// CreateSimulationGroupsFunc represents a factory function for partitioning Simulation instances into one or more SimulationGroups
type CreateSimulationGroupsFunc func(simulations []Simulation) ([]SimulationGroup, error)

// SimGroupKey represents the key for a SimulationGroup.
type SimGroupKey struct {
	NodePoolPriority     int32
	NodeTemplatePriority int32
}

func (k SimGroupKey) String() string {
	return fmt.Sprintf("(%d:%d)", k.NodePoolPriority, k.NodeTemplatePriority)
}

type SimGroupRunResult struct {
	// Name of the group that produced this result.
	Name string
	// Key is the simulation group key (partition key)
	Key               SimGroupKey
	SimulationResults []SimRunResult
}

// SimGroupScores represents the scoring results for the simulation group after running the NodeScorer against the SimGroupRunResult.
type SimGroupScores struct {
	AllNodeScores    []NodeScore
	WinnerScoreIndex int
	WinnerNode       *corev1.Node
}

func (s *SimGroupScores) GetWinner() *NodeScore {
	if s.WinnerScoreIndex < 0 {
		return nil
	}
	return &s.AllNodeScores[s.WinnerScoreIndex]
}
